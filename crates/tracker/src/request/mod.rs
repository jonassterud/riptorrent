mod response;

use anyhow::Result;
use response::Response;
use torrent::Torrent;

#[derive(Debug)]
pub struct Request {
    pub info_hash: Vec<u8>,
    pub peer_id: Vec<u8>,
    pub port: u16,
    pub uploaded: i64,
    pub downloaded: i64,
    pub left: i64,
    pub compact: bool,
    pub no_peer_id: bool,
    pub event: String, // "started" | "stopped" | "completed"
    //pub ip: IpAddr,
    pub numwant: i64,
    //pub key: Vec<u8>,
    //pub trackerid: Vec<u8>,
}

impl Request {
    /// Create a new request
    pub async fn new(
        info_hash: Vec<u8>,
        peer_id: Vec<u8>,
        port: u16,
        uploaded: i64,
        downloaded: i64,
        left: i64,
        event: String,
    ) -> Request {
        Request {
            info_hash,
            peer_id,
            port,
            uploaded,
            downloaded,
            left,
            compact: true,
            no_peer_id: true,
            event,
            //ip,
            numwant: 50,
            //key: vec![],
            //trackerid: vec![],
        }
    }

    /// Create a new request from a `Torrent`.
    ///
    /// # Arguments
    ///
    /// * `torrent` - reference to a `Torrent` struct.
    /// * `peer_id` - the peer id generated by the client.
    pub async fn from_torrent(torrent: &Torrent, peer_id: Vec<u8>) -> Request {
        Request::new(
            torrent.info_hash.clone(),
            peer_id,
            6881_u16,
            0,
            0,
            torrent.get_left(),
            "started".to_string(),
        )
        .await
    }

    pub async fn send_request(&self, announce: String) -> Result<Response> {
        let byte_response = reqwest::get(announce).await?.bytes().await?;

        Ok(Response::from_bytes(byte_response.to_vec())?)
    }
}
