mod response;

use anyhow::Result;
use response::Response;
use torrent::Torrent;

#[derive(Debug)]
pub struct Request {
    pub announce: String,
    pub info_hash: Vec<u8>,
    pub peer_id: Vec<u8>,
    pub port: u16,
    pub uploaded: i64,
    pub downloaded: i64,
    pub left: i64,
    pub event: String, // "started" | "stopped" | "completed"
                       //pub compact: i64,
                       //pub no_peer_id: i64,
                       //pub ip: IpAddr,
                       //pub numwant: i64,
                       //pub key: Vec<u8>,
                       //pub trackerid: Vec<u8>,
}

impl Request {
    /// Create a new request
    #[allow(clippy::too_many_arguments)]
    pub async fn new(
        announce: String,
        info_hash: Vec<u8>,
        peer_id: Vec<u8>,
        port: u16,
        uploaded: i64,
        downloaded: i64,
        left: i64,
        event: String,
    ) -> Request {
        Request {
            announce,
            info_hash,
            peer_id,
            port,
            uploaded,
            downloaded,
            left,
            event,
        }
    }

    /// Create a new request from a `Torrent`.
    ///
    /// # Arguments
    ///
    /// * `torrent` - reference to a `Torrent` struct.
    /// * `peer_id` - the peer id generated by the client.
    pub async fn from_torrent(torrent: &Torrent, peer_id: Vec<u8>) -> Request {
        Request::new(
            torrent.announce.clone(),
            torrent.info_hash.clone(),
            peer_id,
            6881_u16,
            0,
            0,
            torrent.get_left(),
            "started".to_string(),
        )
        .await
    }

    /// Send a tracker request.
    pub async fn send_request(&self) -> Result<Response> {
        //println!("{}", self.announce);

        let final_url = format!(
            "{}?info_hash={}&peer_id={}&port={}&uploaded={}&downloaded={}&left={}&event={}",
            self.announce,
            urlencoding::encode_binary(&self.info_hash),
            urlencoding::encode_binary(&self.peer_id),
            urlencoding::encode(&self.port.to_string()),
            urlencoding::encode(&self.uploaded.to_string()),
            urlencoding::encode(&self.downloaded.to_string()),
            urlencoding::encode(&self.left.to_string()),
            urlencoding::encode(&self.event.to_string()),
        );

        let bytes = reqwest::get(final_url).await?.bytes().await?;
        Response::from_bytes(bytes.to_vec())
    }
}
